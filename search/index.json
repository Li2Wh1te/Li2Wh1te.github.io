[{"content":"æ•°ç»„ æ¦‚è¿° æ•°ç»„æ˜¯ç”±ç›¸åŒç±»å‹å…ƒç´ çš„é›†åˆç»„æˆçš„æ•°æ®ç»“æ„ï¼Œè®¡ç®—æœºä¼šä¸ºæ•°ç»„åˆ†é…ä¸€å—è¿ç»­çš„å†…å­˜ä¿å­˜å…¶ä¸­çš„å…ƒç´ ï¼Œå¯ä»¥é€šè¿‡æ•°ç»„ä¸­å…ƒç´ çš„ç´¢å¼•å¿«é€Ÿè®¿é—®ç‰¹å®šå…ƒç´ ã€‚æ•°ç»„ä½œä¸ºåŸºæœ¬çš„æ•°æ®ç±»å‹ï¼Œé€šå¸¸ç”¨ä¸¤ä¸ªç»´åº¦æè¿°ï¼šæ•°ç»„ä¸­å­˜å‚¨çš„å…ƒç´ ç±»å‹å’Œæ•°ç»„é•¿åº¦ï¼Œæ•°ç»„åœ¨åˆå§‹åŒ–ä¹‹åå¤§å°æ— æ³•æ”¹å˜ã€‚\nåˆå§‹åŒ– æ•°ç»„çš„åˆå§‹åŒ–åˆ†ä¸ºä¸¤ç§ï¼šä¸€ç§æ˜¯æ˜¾å¼çš„æŒ‡å®šæ•°ç»„å¤§å°ï¼Œå¦ä¸€ç§æ˜¯ä½¿ç”¨ [...] Tå£°æ˜æ•°ç»„ï¼ŒGo è¯­è¨€ä¼šåœ¨ç¼–è¯‘æœŸé—´é€šè¿‡æºä»£ç æ¨å¯¼æ•°ç»„çš„å¤§å°ã€‚\n1 2  arr1 := [3]int{1, 2, 3} arr2 := [...]int{1, 2, 3}   ä»¥ä¸Šä¸¤ç§æ–¹å¼å¾—åˆ°çš„ç»“æœæ˜¯ç›¸åŒçš„ï¼Œåä¸€ç§å£°æ˜æ–¹å¼åœ¨ç¼–è¯‘æœŸé—´ä¼šè¢«è½¬æ¢æˆå‰ä¸€ç§ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨å¯¹æ•°ç»„å¤§å°çš„æ¨å¯¼ã€‚\nå¯¹äºä¸€ä¸ªç”±å­—é¢é‡ç»„æˆçš„æ•°ç»„ï¼Œæ ¹æ®æ•°ç»„å…ƒç´ æ•°é‡çš„ä¸åŒï¼Œç¼–è¯‘å™¨ä¼šåœ¨è´Ÿè´£åˆå§‹åŒ–å­—é¢é‡çš„ cmd/compile/internal/gc.anylit å‡½æ•°ä¸­åšä¸¤ç§ä¸åŒçš„ä¼˜åŒ–ã€‚åœ¨ä¸è€ƒè™‘é€ƒé€¸åˆ†æçš„å‰æä¸‹ï¼š\n å½“å…ƒç´ æ•°é‡å°äºæˆ–è€…ç­‰äº 4 ä¸ªæ—¶ï¼Œä¼šç›´æ¥å°†æ•°ç»„ä¸­çš„å…ƒç´ æ”¾ç½®åœ¨æ ˆä¸Š å½“å…ƒç´ æ•°é‡å¤§äº 4 ä¸ªæ—¶ï¼Œä¼šå°†æ•°ç»„ä¸­çš„å…ƒç´ æ”¾ç½®åˆ°é™æ€åŒºå¹¶åœ¨è¿è¡Œæ—¶å–å‡º  åˆ‡ç‰‡ï¼ˆSliceï¼‰ æ•°æ®ç»“æ„ ä¸€ä¸ªsliceç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šæŒ‡é’ˆã€é•¿åº¦ã€å®¹é‡ã€‚\n1 2 3 4 5 6  // runtime/slice.go type slice struct { array unsafe.Pointer // å…ƒç´ æŒ‡é’ˆ \tlen int // é•¿åº¦ \tcap int // å®¹é‡ }   æŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªsliceå…ƒç´ å¯¹åº”çš„åº•å±‚æ•°ç»„å…ƒç´ çš„åœ°å€ï¼Œè¦æ³¨æ„çš„æ˜¯sliceçš„ç¬¬ä¸€ä¸ªå…ƒç´ å¹¶ä¸ä¸€å®šå°±æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚é•¿åº¦å¯¹åº”sliceä¸­å…ƒç´ çš„æ•°ç›®ï¼›é•¿åº¦ä¸èƒ½è¶…è¿‡å®¹é‡ï¼Œå®¹é‡ä¸€èˆ¬æ˜¯ä»sliceçš„å¼€å§‹ä½ç½®åˆ°åº•å±‚æ•°æ®çš„ç»“å°¾ä½ç½®ã€‚\nåˆå§‹åŒ– Goè¯­è¨€åŒ…å«ä¸‰ç§åˆå§‹åŒ–sliceçš„æ–¹å¼ï¼š\n é€šè¿‡ä¸‹æ ‡çš„æ–¹å¼è·å¾—æ•°ç»„æˆ–æ˜¯åˆ‡ç‰‡çš„ä¸€éƒ¨åˆ† ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–æ–°çš„åˆ‡ç‰‡ ä½¿ç”¨å…³é”®å­—makeåˆ›å»ºåˆ‡ç‰‡  1 2 3  arr[0:3] or slice[0:3] slice := []int{1, 2, 3} slice := make([]int, 10)   è¿½åŠ å’Œæ‰©å®¹ ä½¿ç”¨appendå¯ä»¥å‘sliceè¿½åŠ å…ƒç´ ï¼Œå®é™…ä¸Šæ˜¯å¾€åº•å±‚æ•°ç»„æ·»åŠ å…ƒç´ ã€‚ä¸è¿‡å› ä¸ºåº•å±‚æ•°ç»„çš„å®¹é‡å›ºå®šçš„ï¼Œæ‰€ä»¥åœ¨å®¹é‡ä¸è¶³æ—¶ï¼Œä¼šè§¦å‘sliceçš„æ‰©å®¹ã€‚\nåœ¨1.18ç‰ˆæœ¬æ›´æ–°ä¹‹åï¼Œsliceçš„æ‰©å®¹ç­–ç•¥å˜ä¸ºäº†ï¼š\n å¦‚æœæœŸæœ›å®¹é‡å¤§äºsliceåŸå®¹é‡çš„ä¸¤å€å°±ä¼šç›´æ¥ä½¿ç”¨æœŸæœ›å®¹é‡ å½“sliceåŸå®¹é‡xå°äº256æ—¶ï¼Œæ–°å®¹é‡yä¸ºåŸæ¥çš„ä¸¤å€ å½“sliceåŸå®¹é‡xå¤§äºç­‰äº256æ—¶ï¼Œæ–°å®¹é‡y = x + (x + 3*256) / 4  ä»¥ä¸Šåªæ˜¯ç¡®å®šåˆ‡ç‰‡çš„å¤§è‡´å®¹é‡ï¼Œä¸‹é¢è¿˜éœ€è¦æ ¹æ®åˆ‡ç‰‡ä¸­çš„å…ƒç´ å¤§å°è¿›è¡Œå†…å­˜å¯¹é½ã€‚runtime.roundupsize å‡½æ•°ä¼šå°†å¾…ç”³è¯·çš„å†…å­˜å‘ä¸Šå–æ•´ï¼Œå–æ•´æ—¶ä¼šä½¿ç”¨ runtime.class_to_size æ•°ç»„ï¼Œä½¿ç”¨è¯¥æ•°ç»„ä¸­çš„æ•´æ•°å¯ä»¥æé«˜å†…å­˜çš„åˆ†é…æ•ˆç‡å¹¶å‡å°‘ç¢ç‰‡ã€‚\nå“ˆå¸Œè¡¨ å“ˆå¸Œè¡¨æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„æœ€é‡è¦æ•°æ®ç»“æ„ä¹‹ä¸€ï¼Œè¿™ä¸ä»…å› ä¸ºå®ƒ ğ‘‚(1) çš„è¯»å†™æ€§èƒ½éå¸¸ä¼˜ç§€ï¼Œè¿˜å› ä¸ºå®ƒæä¾›äº†é”®å€¼ä¹‹é—´çš„æ˜ å°„ã€‚æƒ³è¦å®ç°ä¸€ä¸ªæ€§èƒ½ä¼˜å¼‚çš„å“ˆå¸Œè¡¨ï¼Œéœ€è¦æ³¨æ„ä¸¤ä¸ªå…³é”®ç‚¹ â€”â€” å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³æ–¹æ³•ã€‚\nè®¾è®¡åŸç† å“ˆå¸Œå‡½æ•° å®ç°å“ˆå¸Œè¡¨çš„å…³é”®ç‚¹åœ¨äºå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©ï¼Œå“ˆå¸Œå‡½æ•°çš„é€‰æ‹©åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šèƒ½å¤Ÿå†³å®šå“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°åº”è¯¥èƒ½å¤Ÿå°†ä¸åŒé”®æ˜ å°„åˆ°ä¸åŒçš„ç´¢å¼•ä¸Šï¼Œè¿™è¦æ±‚å“ˆå¸Œå‡½æ•°çš„è¾“å‡ºèŒƒå›´å¤§äºè¾“å…¥èŒƒå›´ï¼Œä½†æ˜¯ç”±äºé”®çš„æ•°é‡ä¼šè¿œè¿œå¤§äºæ˜ å°„çš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œè¿™ä¸ªç†æƒ³çš„æ•ˆæœæ˜¯ä¸å¯èƒ½å®ç°çš„ã€‚\nå¦‚æœä½¿ç”¨ç»“æœåˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„å“ˆå¸Œå‡½æ•°ï¼Œé‚£ä¹ˆå“ˆå¸Œçš„å¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(1) ï¼›ä½†æ˜¯å¦‚æœå“ˆå¸Œå‡½æ•°çš„ç»“æœåˆ†å¸ƒä¸å‡åŒ€ï¼Œé‚£ä¹ˆæ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å¯èƒ½ä¼šè¾¾åˆ° ğ‘‚(ğ‘›) ï¼Œç”±æ­¤çœ‹æ¥ï¼Œä½¿ç”¨å¥½çš„å“ˆå¸Œå‡½æ•°æ˜¯è‡³å…³é‡è¦çš„ã€‚\nå†²çªè§£å†³ åœ¨é€šå¸¸æƒ…å†µä¸‹ï¼Œå“ˆå¸Œå‡½æ•°è¾“å…¥çš„èŒƒå›´ä¸€å®šä¼šè¿œè¿œå¤§äºè¾“å‡ºçš„èŒƒå›´ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨å“ˆå¸Œè¡¨æ—¶ä¸€å®šä¼šé‡åˆ°å†²çªï¼Œå“ªæ€•æˆ‘ä»¬ä½¿ç”¨äº†å®Œç¾çš„å“ˆå¸Œå‡½æ•°ï¼Œå½“è¾“å…¥çš„é”®è¶³å¤Ÿå¤šä¹Ÿä¼šäº§ç”Ÿå†²çªã€‚ç„¶è€Œå¤šæ•°çš„å“ˆå¸Œå‡½æ•°éƒ½æ˜¯ä¸å¤Ÿå®Œç¾çš„ï¼Œæ‰€ä»¥ä»ç„¶å­˜åœ¨å‘ç”Ÿå“ˆå¸Œç¢°æ’çš„å¯èƒ½ï¼Œè¿™æ—¶å°±éœ€è¦ä¸€äº›æ–¹æ³•æ¥è§£å†³å“ˆå¸Œç¢°æ’çš„é—®é¢˜ï¼Œå¸¸è§æ–¹æ³•çš„å°±æ˜¯å¼€æ”¾å¯»å€æ³•å’Œæ‹‰é“¾æ³•ã€‚\nå¼€æ”¾å¯»å€æ³• å¼€æ”¾å¯»å€æ³•æ˜¯ä¸€ç§åœ¨å“ˆå¸Œè¡¨ä¸­è§£å†³å“ˆå¸Œç¢°æ’çš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä¾æ¬¡æ¢æµ‹å’Œæ¯”è¾ƒæ•°ç»„ä¸­çš„å…ƒç´ ä»¥åˆ¤æ–­ç›®æ ‡é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ã€‚\nå¼€æ”¾å¯»å€æ³•ä¸­å¯¹æ€§èƒ½å½±å“æœ€å¤§çš„æ˜¯è£…è½½å› å­ï¼Œå®ƒæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ä¸æ•°ç»„å¤§å°çš„æ¯”å€¼ã€‚éšç€è£…è½½å› å­çš„å¢åŠ ï¼Œçº¿æ€§æ¢æµ‹çš„å¹³å‡ç”¨æ—¶å°±ä¼šé€æ¸å¢åŠ ï¼Œè¿™ä¼šå½±å“å“ˆå¸Œè¡¨çš„è¯»å†™æ€§èƒ½ã€‚å½“è£…è½½ç‡è¶…è¿‡ 70% ä¹‹åï¼Œå“ˆå¸Œè¡¨çš„æ€§èƒ½å°±ä¼šæ€¥å‰§ä¸‹é™ï¼Œè€Œä¸€æ—¦è£…è½½ç‡è¾¾åˆ° 100%ï¼Œæ•´ä¸ªå“ˆå¸Œè¡¨å°±ä¼šå®Œå…¨å¤±æ•ˆï¼Œè¿™æ—¶æŸ¥æ‰¾å’Œæ’å…¥ä»»æ„å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ ğ‘‚(ğ‘›) çš„ï¼Œè¿™æ—¶éœ€è¦éå†æ•°ç»„ä¸­çš„å…¨éƒ¨å…ƒç´ ï¼Œæ‰€ä»¥åœ¨å®ç°å“ˆå¸Œè¡¨æ—¶ä¸€å®šè¦å…³æ³¨è£…è½½å› å­çš„å˜åŒ–ã€‚\næ‹‰é“¾æ³• æ‹‰é“¾æ³•ä¼šä½¿ç”¨é“¾è¡¨æ•°ç»„ä½œä¸ºå“ˆå¸Œåº•å±‚çš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒçœ‹æˆå¯ä»¥æ‰©å±•çš„äºŒç»´æ•°ç»„ã€‚\nä¸å¼€æ”¾åœ°å€æ³•ä¸€æ ·ï¼Œæ‹‰é“¾æ³•çš„è£…è½½å› å­ï¼ˆè£…è½½å› å­ = å…ƒç´ æ•°é‡ / æ¡¶æ•°é‡ ï¼‰è¶Šå¤§ï¼Œå“ˆå¸Œçš„è¯»å†™æ€§èƒ½å°±è¶Šå·®ã€‚åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ä½¿ç”¨æ‹‰é“¾æ³•çš„å“ˆå¸Œè¡¨è£…è½½å› å­éƒ½ä¸ä¼šè¶…è¿‡ 1ï¼Œå½“å“ˆå¸Œè¡¨çš„è£…è½½å› å­è¾ƒå¤§æ—¶ä¼šè§¦å‘å“ˆå¸Œçš„æ‰©å®¹ï¼Œåˆ›å»ºæ›´å¤šçš„æ¡¶æ¥å­˜å‚¨å“ˆå¸Œä¸­çš„å…ƒç´ ï¼Œä¿è¯æ€§èƒ½ä¸ä¼šå‡ºç°ä¸¥é‡çš„ä¸‹é™ã€‚å¦‚æœæœ‰ 1000 ä¸ªæ¡¶çš„å“ˆå¸Œè¡¨å­˜å‚¨äº† 10000 ä¸ªé”®å€¼å¯¹ï¼Œå®ƒçš„æ€§èƒ½æ˜¯ä¿å­˜ 1000 ä¸ªé”®å€¼å¯¹çš„ 1/10ï¼Œä½†æ˜¯ä»ç„¶æ¯”åœ¨é“¾è¡¨ä¸­ç›´æ¥è¯»å†™å¥½ 1000 å€ã€‚\næ•°æ®ç»“æ„ runtimeåŒæ—¶ä½¿ç”¨äº†å¤šä¸ªæ•°æ®ç»“æ„ç»„åˆè¡¨ç¤ºå“ˆå¸Œè¡¨ï¼Œå…¶ä¸­runtime.hmapæ˜¯æœ€æ ¸å¿ƒçš„ç»“æ„ä½“ï¼Œå­—æ®µå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go. \t// Make sure this stays in sync with the compiler\u0026#39;s definition. \tcount int // # live cells == size of map. Must be first (used by len() builtin) \tflags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) \tnoverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details \thash0 uint32 // hash seed  buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. \toldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing \tnevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated)  extra *mapextra // optional fields }    countè¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ æ•°é‡ Bè¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨æŒæœ‰çš„ buckets æ•°é‡ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡éƒ½ 2 çš„å€æ•°ï¼Œæ‰€ä»¥è¯¥å­—æ®µä¼šå­˜å‚¨å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯ len(buckets) == 2^B hash0æ˜¯å“ˆå¸Œçš„ç§å­ï¼Œå®ƒèƒ½ä¸ºå“ˆå¸Œå‡½æ•°çš„ç»“æœå¼•å…¥éšæœºæ€§ï¼Œè¿™ä¸ªå€¼åœ¨åˆ›å»ºå“ˆå¸Œè¡¨æ—¶ç¡®å®šï¼Œå¹¶åœ¨è°ƒç”¨å“ˆå¸Œå‡½æ•°æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥ oldbucketsæ˜¯å“ˆå¸Œåœ¨æ‰©å®¹æ—¶ç”¨äºä¿å­˜ä¹‹å‰ buckets çš„å­—æ®µï¼Œå®ƒçš„å¤§å°æ˜¯å½“å‰ buckets çš„ä¸€åŠ  å¦‚ä¸Šå›¾æ‰€ç¤ºå“ˆå¸Œè¡¨ runtime.hmap çš„æ¡¶æ˜¯ runtime.bmapã€‚æ¯ä¸€ä¸ª runtime.bmap éƒ½èƒ½å­˜å‚¨ 8 ä¸ªé”®å€¼å¯¹ï¼Œå½“å“ˆå¸Œè¡¨ä¸­å­˜å‚¨çš„æ•°æ®è¿‡å¤šï¼Œå•ä¸ªæ¡¶å·²ç»è£…æ»¡æ—¶å°±ä¼šä½¿ç”¨ extra.nextOverflow ä¸­æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ã€‚ä¸Šè¿°ä¸¤ç§ä¸åŒçš„æ¡¶åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°†å®ƒä»¬åˆ†åˆ«ç§°ä¸ºæ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ï¼Œä¸Šå›¾ä¸­é»„è‰²çš„ runtime.bmap å°±æ˜¯æ­£å¸¸æ¡¶ï¼Œç»¿è‰²çš„ runtime.bmap æ˜¯æº¢å‡ºæ¡¶ã€‚\næ¡¶çš„ç»“æ„ä½“ runtime.bmap åœ¨ Go è¯­è¨€æºä»£ç ä¸­çš„å®šä¹‰åªåŒ…å«ä¸€ä¸ªç®€å•çš„ tophash å­—æ®µï¼Œtophash å­˜å‚¨äº†é”®çš„å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œé€šè¿‡æ¯”è¾ƒä¸åŒé”®çš„å“ˆå¸Œçš„é«˜ 8 ä½å¯ä»¥å‡å°‘è®¿é—®é”®å€¼å¯¹æ¬¡æ•°ä»¥æé«˜æ€§èƒ½ï¼š\n1 2 3  type bmap struct { tophash [bucketCnt]uint8 }   åœ¨è¿è¡ŒæœŸé—´ï¼Œruntime.bmap ç»“æ„ä½“å…¶å®ä¸æ­¢åŒ…å« tophash å­—æ®µï¼Œå› ä¸ºå“ˆå¸Œè¡¨ä¸­å¯èƒ½å­˜å‚¨ä¸åŒç±»å‹çš„é”®å€¼å¯¹ï¼Œè€Œä¸” Go è¯­è¨€ä¹Ÿä¸æ”¯æŒæ³›å‹ï¼Œæ‰€ä»¥é”®å€¼å¯¹å æ®çš„å†…å­˜ç©ºé—´å¤§å°åªèƒ½åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ¨å¯¼ã€‚runtime.bmap ä¸­çš„å…¶ä»–å­—æ®µåœ¨è¿è¡Œæ—¶ä¹Ÿéƒ½æ˜¯é€šè¿‡è®¡ç®—å†…å­˜åœ°å€çš„æ–¹å¼è®¿é—®çš„ï¼Œæ‰€ä»¥å®ƒçš„å®šä¹‰ä¸­å°±ä¸åŒ…å«è¿™äº›å­—æ®µï¼Œä¸è¿‡æˆ‘ä»¬èƒ½æ ¹æ®ç¼–è¯‘æœŸé—´çš„ cmd/compile/internal/gc.bmap å‡½æ•°é‡å»ºå®ƒçš„ç»“æ„ï¼š\n1 2 3 4 5 6 7  type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr }   éšç€å“ˆå¸Œè¡¨å­˜å‚¨çš„æ•°æ®é€æ¸å¢å¤šï¼Œæˆ‘ä»¬ä¼šæ‰©å®¹å“ˆå¸Œè¡¨æˆ–è€…ä½¿ç”¨é¢å¤–çš„æ¡¶å­˜å‚¨æº¢å‡ºçš„æ•°æ®ï¼Œä¸ä¼šè®©å•ä¸ªæ¡¶ä¸­çš„æ•°æ®è¶…è¿‡ 8 ä¸ªï¼Œä¸è¿‡æº¢å‡ºæ¡¶åªæ˜¯ä¸´æ—¶çš„è§£å†³æ–¹æ¡ˆï¼Œåˆ›å»ºè¿‡å¤šçš„æº¢å‡ºæ¡¶æœ€ç»ˆä¹Ÿä¼šå¯¼è‡´å“ˆå¸Œçš„æ‰©å®¹ã€‚\nè¯»å†™æ“ä½œ è®¿é—® 1 2  v := hash[key] // =\u0026gt; v := *mapaccess1(maptype, hash, \u0026amp;key) v, ok := hash[key] // =\u0026gt; v, ok := mapaccess2(maptype, hash, \u0026amp;key)   èµ‹å€¼è¯­å¥å·¦ä¾§æ¥å—å‚æ•°çš„ä¸ªæ•°ä¼šå†³å®šä½¿ç”¨çš„è¿è¡Œæ—¶æ–¹æ³•ï¼š\n å½“æ¥å—ä¸€ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ runtime.mapaccess1ï¼Œè¯¥å‡½æ•°ä»…ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ç›®æ ‡å€¼çš„æŒ‡é’ˆ å½“æ¥å—ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œä¼šä½¿ç”¨ runtime.mapaccess2ï¼Œé™¤äº†è¿”å›ç›®æ ‡å€¼ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šè¿”å›ä¸€ä¸ªç”¨äºè¡¨ç¤ºå½“å‰é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨çš„ bool å€¼  runtime.mapaccess1 ä¼šå…ˆé€šè¿‡å“ˆå¸Œè¡¨è®¾ç½®çš„å“ˆå¸Œå‡½æ•°ã€ç§å­è·å–å½“å‰é”®å¯¹åº”çš„å“ˆå¸Œï¼Œå†é€šè¿‡ runtime.bucketMask å’Œ runtime.add æ‹¿åˆ°è¯¥é”®å€¼å¯¹æ‰€åœ¨çš„æ¡¶åºå·å’Œå“ˆå¸Œé«˜ä½çš„ 8 ä½æ•°å­—ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(add(h.buckets, (hash\u0026amp;m)*uintptr(t.bucketsize))) top := tophash(hash) bucketloop: for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { break bucketloop } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if alg.equal(key, k) { v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) return v } } } return unsafe.Pointer(\u0026amp;zeroVal[0]) }   åœ¨ bucketloop å¾ªç¯ä¸­ï¼Œå“ˆå¸Œä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­çš„æ•°æ®ï¼Œå®ƒä¼šå…ˆæ¯”è¾ƒå“ˆå¸Œçš„é«˜ 8 ä½å’Œæ¡¶ä¸­å­˜å‚¨çš„ tophashæ˜¯å¦ä¸€è‡´ï¼Œåæ¯”è¾ƒä¼ å…¥çš„keyå’Œæ¡¶ä¸­çš„å€¼ä»¥åŠ é€Ÿæ•°æ®çš„è¯»å†™ã€‚ç”¨äºé€‰æ‹©æ¡¶åºå·çš„æ˜¯å“ˆå¸Œçš„æœ€ä½Bä½ï¼Œè€Œç”¨äºåŠ é€Ÿè®¿é—®çš„æ˜¯å“ˆå¸Œçš„é«˜ 8 ä½ï¼Œè¿™ç§è®¾è®¡èƒ½å¤Ÿå‡å°‘åŒä¸€ä¸ªæ¡¶ä¸­æœ‰å¤§é‡ç›¸ç­‰ tophash çš„æ¦‚ç‡å½±å“æ€§èƒ½ã€‚\nå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¯ä¸€ä¸ªæ¡¶éƒ½æ˜¯ä¸€æ•´ç‰‡çš„å†…å­˜ç©ºé—´ï¼Œå½“å‘ç°æ¡¶ä¸­çš„ tophash ä¸ä¼ å…¥é”®çš„ tophash åŒ¹é…ä¹‹åï¼Œæˆ‘ä»¬ä¼šé€šè¿‡æŒ‡é’ˆå’Œåç§»é‡è·å–å“ˆå¸Œä¸­å­˜å‚¨çš„é”® keys[0] å¹¶ä¸ key æ¯”è¾ƒï¼Œå¦‚æœä¸¤è€…ç›¸åŒå°±ä¼šè·å–ç›®æ ‡å€¼çš„æŒ‡é’ˆ values[0] å¹¶è¿”å›ã€‚\nå¦ä¸€ä¸ªåŒæ ·ç”¨äºè®¿é—®å“ˆå¸Œè¡¨ä¸­æ•°æ®çš„ runtime.mapaccess2 åªæ˜¯åœ¨ runtime.mapaccess1 çš„åŸºç¡€ä¸Šå¤šè¿”å›äº†ä¸€ä¸ªæ ‡è¯†é”®å€¼å¯¹æ˜¯å¦å­˜åœ¨çš„ bool å€¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) { ... bucketloop: for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if b.tophash[i] == emptyRest { break bucketloop } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if alg.equal(key, k) { v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) return v, true } } } return unsafe.Pointer(\u0026amp;zeroVal[0]), false }   å†™å…¥ å½“å½¢å¦‚ hash[k] çš„è¡¨è¾¾å¼å‡ºç°åœ¨èµ‹å€¼ç¬¦å·å·¦ä¾§æ—¶ï¼Œè¯¥è¡¨è¾¾å¼ä¹Ÿä¼šåœ¨ç¼–è¯‘æœŸé—´è½¬æ¢æˆ runtime.mapassign å‡½æ•°çš„è°ƒç”¨ï¼Œè¯¥å‡½æ•°ä¸ runtime.mapaccess1 æ¯”è¾ƒç›¸ä¼¼ï¼Œæˆ‘ä»¬å°†å…¶åˆ†æˆå‡ ä¸ªéƒ¨åˆ†ä¾æ¬¡åˆ†æï¼Œé¦–å…ˆæ˜¯å‡½æ•°ä¼šæ ¹æ®ä¼ å…¥çš„é”®æ‹¿åˆ°å¯¹åº”çš„å“ˆå¸Œå’Œæ¡¶ï¼š\n1 2 3 4 5 6 7 8 9 10  func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) h.flags ^= hashWriting again: bucket := hash \u0026amp; bucketMask(h.B) b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize))) top := tophash(hash)   ç„¶åé€šè¿‡éå†æ¯”è¾ƒæ¡¶ä¸­å­˜å‚¨çš„ tophash å’Œé”®çš„å“ˆå¸Œï¼Œå¦‚æœæ‰¾åˆ°äº†ç›¸åŒç»“æœå°±ä¼šè¿”å›ç›®æ ‡ä½ç½®çš„åœ°å€ã€‚å…¶ä¸­ inserti è¡¨ç¤ºç›®æ ‡å…ƒç´ çš„åœ¨æ¡¶ä¸­çš„ç´¢å¼•ï¼Œinsertk å’Œ val åˆ†åˆ«è¡¨ç¤ºé”®å€¼å¯¹çš„åœ°å€ï¼Œè·å¾—ç›®æ ‡åœ°å€ä¹‹åä¼šé€šè¿‡ç®—æœ¯è®¡ç®—å¯»å€è·å¾—é”®å€¼å¯¹ k å’Œ valï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  var inserti *uint8 var insertk unsafe.Pointer var val unsafe.Pointer bucketloop: for { for i := uintptr(0); i \u0026lt; bucketCnt; i++ { if b.tophash[i] != top { if isEmpty(b.tophash[i]) \u0026amp;\u0026amp; inserti == nil { inserti = \u0026amp;b.tophash[i] insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) } if b.tophash[i] == emptyRest { break bucketloop } continue } k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if !alg.equal(key, k) { continue } val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) goto done } ovf := b.overflow(t) if ovf == nil { break } b = ovf }   ä¸Šè¿°çš„ for å¾ªç¯ä¼šä¾æ¬¡éå†æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶ä¸­å­˜å‚¨çš„æ•°æ®ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¼šåˆ†åˆ«åˆ¤æ–­ tophash æ˜¯å¦ç›¸ç­‰ã€key æ˜¯å¦ç›¸ç­‰ï¼Œéå†ç»“æŸåä¼šä»å¾ªç¯ä¸­è·³å‡ºã€‚\nå¦‚æœå½“å‰æ¡¶å·²ç»æ»¡äº†ï¼Œå“ˆå¸Œä¼šè°ƒç”¨ runtime.hmap.newoverflow åˆ›å»ºæ–°æ¡¶æˆ–è€…ä½¿ç”¨ runtime.hmap é¢„å…ˆåœ¨ noverflow ä¸­åˆ›å»ºå¥½çš„æ¡¶æ¥ä¿å­˜æ•°æ®ï¼Œæ–°åˆ›å»ºçš„æ¡¶ä¸ä»…ä¼šè¢«è¿½åŠ åˆ°å·²æœ‰æ¡¶çš„æœ«å°¾ï¼Œè¿˜ä¼šå¢åŠ å“ˆå¸Œè¡¨çš„ noverflow è®¡æ•°å™¨ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  if inserti == nil { newb := h.newoverflow(t, b) inserti = \u0026amp;newb.tophash[0] insertk = add(unsafe.Pointer(newb), dataOffset) val = add(insertk, bucketCnt*uintptr(t.keysize)) } typedmemmove(t.key, insertk, key) *inserti = top h.count++ done: return val }   å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­ä¸å­˜åœ¨ï¼Œå“ˆå¸Œä¼šä¸ºæ–°é”®å€¼å¯¹è§„åˆ’å­˜å‚¨çš„å†…å­˜åœ°å€ï¼Œé€šè¿‡ runtime.typedmemmove å°†é”®ç§»åŠ¨åˆ°å¯¹åº”çš„å†…å­˜ç©ºé—´ä¸­å¹¶è¿”å›é”®å¯¹åº”å€¼çš„åœ°å€ valã€‚å¦‚æœå½“å‰é”®å€¼å¯¹åœ¨å“ˆå¸Œä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ä¼šç›´æ¥è¿”å›ç›®æ ‡åŒºåŸŸçš„å†…å­˜åœ°å€ï¼Œå“ˆå¸Œå¹¶ä¸ä¼šåœ¨ runtime.mapassign è¿™ä¸ªè¿è¡Œæ—¶å‡½æ•°ä¸­å°†å€¼æ‹·è´åˆ°æ¡¶ä¸­ï¼Œè¯¥å‡½æ•°åªä¼šè¿”å›å†…å­˜åœ°å€ï¼ŒçœŸæ­£çš„èµ‹å€¼æ“ä½œæ˜¯åœ¨ç¼–è¯‘æœŸé—´æ’å…¥çš„ï¼š\n1 2 3 4  00018 (+5) CALL runtime.mapassign_fast64(SB) 00020 (5) MOVQ 24(SP), DI ;; DI = \u0026amp;value 00026 (5) LEAQ go.string.\u0026#34;88\u0026#34;(SB), AX ;; AX = \u0026amp;\u0026#34;88\u0026#34; 00027 (5) MOVQ AX, (DI) ;; *DI = AX   runtime.mapassign_fast64 ä¸ runtime.mapassign å‡½æ•°çš„é€»è¾‘å·®ä¸å¤šï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨çš„æ˜¯åé¢çš„ä¸‰è¡Œä»£ç ï¼Œå…¶ä¸­ 24(SP) æ˜¯è¯¥å‡½æ•°è¿”å›çš„å€¼åœ°å€ï¼Œæˆ‘ä»¬é€šè¿‡ LEAQ æŒ‡ä»¤å°†å­—ç¬¦ä¸²çš„åœ°å€å­˜å‚¨åˆ°å¯„å­˜å™¨ AX ä¸­ï¼ŒMOVQ æŒ‡ä»¤å°†å­—ç¬¦ä¸² \u0026ldquo;88\u0026rdquo; å­˜å‚¨åˆ°äº†ç›®æ ‡åœ°å€ä¸Šå®Œæˆäº†è¿™æ¬¡å“ˆå¸Œçš„å†™å…¥ã€‚\næ‰©å®¹ ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¼šè§¦å‘mapçš„æ‰©å®¹æ“ä½œï¼š\n è£…è½½å› å­è¶…è¿‡é˜ˆå€¼ï¼Œæºç é‡Œå®šä¹‰çš„é˜ˆå€¼æ˜¯ 6.5 overflow çš„ bucket æ•°é‡è¿‡å¤šï¼šå½“ B å°äº 15ï¼Œä¹Ÿå°±æ˜¯ bucket æ€»æ•° 2^B å°äº 2^15 æ—¶ï¼Œå¦‚æœ overflow çš„ bucket æ•°é‡è¶…è¿‡ 2^Bï¼›å½“ B \u0026gt;= 15ï¼Œä¹Ÿå°±æ˜¯ bucket æ€»æ•° 2^B å¤§äºç­‰äº 2^15ï¼Œå¦‚æœ overflow çš„ bucket æ•°é‡è¶…è¿‡ 2^15  Goæºç å®šä¹‰è£…è½½å› å­ï¼šloadFactor = count / (2^B)ã€‚countå°±æ˜¯å…ƒç´ mapçš„ä¸ªæ•°ï¼Œ2^Bè¡¨ç¤ºbucketçš„æ•°é‡ã€‚å¯¹åº”çš„æ‰©å®¹æºç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // src/runtime/hashmap.go/mapassign  // è§¦å‘æ‰©å®¹æ—¶æœº if !h.growing() \u0026amp;\u0026amp; (overLoadFactor(int64(h.count), h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { hashGrow(t, h) } // è£…è½½å› å­è¶…è¿‡ 6.5 func overLoadFactor(count int64, B uint8) bool { return count \u0026gt;= bucketCnt \u0026amp;\u0026amp; float32(count) \u0026gt;= loadFactor*float32((uint64(1)\u0026lt;\u0026lt;B)) } // overflow buckets å¤ªå¤š func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { if B \u0026lt; 16 { return noverflow \u0026gt;= uint16(1)\u0026lt;\u0026lt;B } return noverflow \u0026gt;= 1\u0026lt;\u0026lt;15 }   å¯¹äºå‘½ä¸­æ¡ä»¶ 1ï¼Œ2 çš„é™åˆ¶ï¼Œéƒ½ä¼šå‘ç”Ÿæ‰©å®¹ã€‚ä½†æ˜¯æ‰©å®¹çš„ç­–ç•¥å¹¶ä¸ç›¸åŒï¼Œæ¯•ç«Ÿä¸¤ç§æ¡ä»¶åº”å¯¹çš„åœºæ™¯ä¸åŒã€‚\nå¯¹äºæ¡ä»¶ 1ï¼Œå…ƒç´ å¤ªå¤šï¼Œè€Œ bucket æ•°é‡å¤ªå°‘ï¼Œå¾ˆç®€å•ï¼šå°† B åŠ  1ï¼Œbucket æœ€å¤§æ•°é‡ï¼ˆ2^Bï¼‰ç›´æ¥å˜æˆåŸæ¥ bucket æ•°é‡çš„ 2 å€ã€‚äºæ˜¯ï¼Œå°±æœ‰æ–°è€ bucket äº†ã€‚æ³¨æ„ï¼Œè¿™æ—¶å€™å…ƒç´ éƒ½åœ¨è€ bucket é‡Œï¼Œè¿˜æ²¡è¿ç§»åˆ°æ–°çš„ bucket æ¥ã€‚è€Œä¸”ï¼Œæ–° bucket åªæ˜¯æœ€å¤§æ•°é‡å˜ä¸ºåŸæ¥æœ€å¤§æ•°é‡ï¼ˆ2^Bï¼‰çš„ 2 å€ï¼ˆ2^B * 2ï¼‰ã€‚\nå¯¹äºæ¡ä»¶ 2ï¼Œå…¶å®å…ƒç´ æ²¡é‚£ä¹ˆå¤šï¼Œä½†æ˜¯ overflow bucket æ•°ç‰¹åˆ«å¤šï¼Œè¯´æ˜å¾ˆå¤š bucket éƒ½æ²¡è£…æ»¡ã€‚è§£å†³åŠæ³•å°±æ˜¯å¼€è¾Ÿä¸€ä¸ªæ–° bucket ç©ºé—´ï¼Œå°†è€ bucket ä¸­çš„å…ƒç´ ç§»åŠ¨åˆ°æ–° bucketï¼Œä½¿å¾—åŒä¸€ä¸ª bucket ä¸­çš„ key æ’åˆ—åœ°æ›´ç´§å¯†ã€‚è¿™æ ·ï¼ŒåŸæ¥ï¼Œåœ¨ overflow bucket ä¸­çš„ key å¯ä»¥ç§»åŠ¨åˆ° bucket ä¸­æ¥ã€‚ç»“æœæ˜¯èŠ‚çœç©ºé—´ï¼Œæé«˜ bucket åˆ©ç”¨ç‡ï¼Œmap çš„æŸ¥æ‰¾å’Œæ’å…¥æ•ˆç‡è‡ªç„¶å°±ä¼šæå‡ã€‚\nå¯¹äºæ¡ä»¶ 2 çš„è§£å†³æ–¹æ¡ˆï¼Œè¿˜å¯èƒ½ä¸€ä¸ªæç«¯çš„æƒ…å†µï¼šå¦‚æœæ’å…¥ map çš„ key å“ˆå¸Œéƒ½ä¸€æ ·ï¼Œå°±ä¼šè½åˆ°åŒä¸€ä¸ª bucket é‡Œï¼Œè¶…è¿‡ 8 ä¸ªå°±ä¼šäº§ç”Ÿ overflow bucketï¼Œç»“æœä¹Ÿä¼šé€ æˆ overflow bucket æ•°è¿‡å¤šã€‚ç§»åŠ¨å…ƒç´ å…¶å®è§£å†³ä¸äº†é—®é¢˜ï¼Œå› ä¸ºè¿™æ—¶æ•´ä¸ªå“ˆå¸Œè¡¨å·²ç»é€€åŒ–æˆäº†ä¸€ä¸ªé“¾è¡¨ï¼Œæ“ä½œæ•ˆç‡å˜æˆäº† O(n)ã€‚\nç”±äº map æ‰©å®¹éœ€è¦å°†åŸæœ‰çš„ key/value é‡æ–°æ¬è¿åˆ°æ–°çš„å†…å­˜åœ°å€ï¼Œå¦‚æœæœ‰å¤§é‡çš„ key/value éœ€è¦æ¬è¿ï¼Œä¼šéå¸¸å½±å“æ€§èƒ½ã€‚å› æ­¤ Go map çš„æ‰©å®¹é‡‡å–äº†ä¸€ç§ç§°ä¸ºâ€œæ¸è¿›å¼â€åœ°æ–¹å¼ï¼ŒåŸæœ‰çš„ key å¹¶ä¸ä¼šä¸€æ¬¡æ€§æ¬è¿å®Œæ¯•ï¼Œæ¯æ¬¡æœ€å¤šåªä¼šæ¬è¿ 2 ä¸ª bucketã€‚\næ‰©å®¹çš„å…¥å£æ˜¯runtime.hashGrow()å‡½æ•°çš„æºç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func hashGrow(t *maptype, h *hmap) { // B+1 ç›¸å½“äºæ˜¯åŸæ¥ 2 å€çš„ç©ºé—´ \tbigger := uint8(1) // å¯¹åº”è§¦å‘æ¡ä»¶ 2 \tif !overLoadFactor(int64(h.count), h.B) { // è¿›è¡Œç­‰é‡çš„å†…å­˜æ‰©å®¹ï¼Œæ‰€ä»¥ B ä¸å˜ \tbigger = 0 h.flags |= sameSizeGrow } // å°†è€ buckets æŒ‚åˆ° buckets ä¸Š \toldbuckets := h.buckets // ç”³è¯·æ–°çš„ buckets ç©ºé—´ \tnewbuckets, nextOverflow := makeBucketArray(t, h.B+bigger) flags := h.flags \u0026amp;^ (iterator | oldIterator) if h.flags\u0026amp;iterator != 0 { flags |= oldIterator } // æäº¤ grow çš„åŠ¨ä½œ \th.B += bigger h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets // æ¬è¿è¿›åº¦ä¸º 0 \th.nevacuate = 0 // overflow buckets æ•°ä¸º 0 \th.noverflow = 0 // â€¦â€¦ }   å¯ä»¥çœ‹å‡ºhashGrow()å‡½æ•°å¹¶æ²¡æœ‰çœŸæ­£çš„è¿ç§»bucketï¼Œè€Œåªæ˜¯åˆ†é…å¥½äº†æ–°çš„ bucketsï¼Œå¹¶å°†è€çš„ buckets æŒ‚åˆ°äº† oldbuckets å­—æ®µä¸Šã€‚\nçœŸæ­£æ¬è¿ buckets çš„åŠ¨ä½œåœ¨ growWork() å‡½æ•°ä¸­ï¼Œè€Œè°ƒç”¨ growWork() å‡½æ•°çš„åŠ¨ä½œæ˜¯åœ¨ mapassign å’Œ mapdelete å‡½æ•°ä¸­ã€‚ä¹Ÿå°±æ˜¯æ’å…¥æˆ–ä¿®æ”¹ã€åˆ é™¤ key çš„æ—¶å€™ï¼Œéƒ½ä¼šå°è¯•è¿›è¡Œæ¬è¿ buckets çš„å·¥ä½œã€‚å…ˆæ£€æŸ¥ oldbuckets æ˜¯å¦æ¬è¿å®Œæ¯•ï¼Œå…·ä½“æ¥è¯´å°±æ˜¯æ£€æŸ¥ oldbuckets æ˜¯å¦ä¸º nilã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  func growWork(t *maptype, h *hmap, bucket uintptr) { // ç¡®è®¤æ¬è¿è€çš„ bucket å¯¹åº”æ­£åœ¨ä½¿ç”¨çš„ bucket \tevacuate(t, h, bucket\u0026amp;h.oldbucketmask()) // å†æ¬è¿ä¸€ä¸ª bucketï¼Œä»¥åŠ å¿«æ¬è¿è¿›ç¨‹ \tif h.growing() { evacuate(t, h, h.nevacuate) } } func (h *hmap) growing() bool { // å¦‚æœoldbucketsä¸ä¸ºnilï¼Œè¯´æ˜éœ€è¦æ¬è¿ \treturn h.oldbuckets != nil }   bucket\u0026amp;h.oldbucketmask() è¿™è¡Œä»£ç ï¼Œå¦‚æºç æ³¨é‡Šé‡Œè¯´çš„ï¼Œæ˜¯ä¸ºäº†ç¡®è®¤æ¬è¿çš„ bucket æ˜¯æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„ bucketã€‚oldbucketmask() å‡½æ•°è¿”å›æ‰©å®¹å‰çš„ map çš„ bucketmaskã€‚bucketmaskçš„ä½œç”¨å°±æ˜¯ä¸ç”¨keyè®¡ç®—å‡ºæ¥çš„å“ˆå¸Œå€¼ç›¸ä¸ï¼Œå¾—åˆ°çš„ç»“æœå°±æ˜¯keyåº”è¯¥è½å…¥çš„bucketã€‚æ¯”å¦‚B=5ï¼Œé‚£ä¹ˆ bucketmask çš„ä½äº”ä½å°±æ˜¯ 11111 ,å…¶ä½™ä½å°±æ˜¯0ï¼Œhash å€¼ä¸å…¶ç›¸ä¸çš„æ„æ€æ˜¯ï¼Œåªæœ‰ hash å€¼çš„ä½ 5 ä½å†³ç­– key åˆ°åº•è½å…¥å“ªä¸ª bucketã€‚\næ¥ä¸‹æ¥æ˜¯æ¬è¿çš„å…³é”®å‡½æ•° evacuate()çš„æºç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186  func evacuate(t *maptype, h *hmap, oldbucket uintptr) { // å®šä½è€çš„ bucket åœ°å€ \tb := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) // ç»“æœæ˜¯ 2^Bï¼Œå¦‚ B = 5ï¼Œç»“æœä¸º32 \tnewbit := h.noldbuckets() // key çš„å“ˆå¸Œå‡½æ•° \talg := t.key.alg // å¦‚æœ b æ²¡æœ‰è¢«æ¬è¿è¿‡ \tif !evacuated(b) { var ( // è¡¨ç¤ºbucket ç§»åŠ¨çš„ç›®æ ‡åœ°å€ \tx, y *bmap // æŒ‡å‘ x,y ä¸­çš„ key/val \txi, yi int // æŒ‡å‘ xï¼Œy ä¸­çš„ key \txk, yk unsafe.Pointer // æŒ‡å‘ xï¼Œy ä¸­çš„ value \txv, yv unsafe.Pointer ) // é»˜è®¤æ˜¯ç­‰ size æ‰©å®¹ï¼Œå‰å bucket åºå·ä¸å˜ \t// ä½¿ç”¨ x æ¥è¿›è¡Œæ¬è¿ \tx = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize))) xi = 0 xk = add(unsafe.Pointer(x), dataOffset) xv = add(xk, bucketCnt*uintptr(t.keysize))ã€ // å¦‚æœä¸æ˜¯ç­‰ size æ‰©å®¹ï¼Œå‰å bucket åºå·æœ‰å˜ \t// ä½¿ç”¨ y æ¥è¿›è¡Œæ¬è¿ \tif !h.sameSizeGrow() { // y ä»£è¡¨çš„ bucket åºå·å¢åŠ äº† 2^B \ty = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize))) yi = 0 yk = add(unsafe.Pointer(y), dataOffset) yv = add(yk, bucketCnt*uintptr(t.keysize)) } // éå†æ‰€æœ‰çš„ bucketï¼ŒåŒ…æ‹¬ overflow buckets \t// b æ˜¯è€çš„ bucket åœ°å€ \tfor ; b != nil; b = b.overflow(t) { k := add(unsafe.Pointer(b), dataOffset) v := add(k, bucketCnt*uintptr(t.keysize)) // éå† bucket ä¸­çš„æ‰€æœ‰ cell \tfor i := 0; i \u0026lt; bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) { // å½“å‰ cell çš„ top hash å€¼ \ttop := b.tophash[i] // å¦‚æœ cell ä¸ºç©ºï¼Œå³æ²¡æœ‰ key \tif top == empty { // é‚£å°±æ ‡å¿—å®ƒè¢«\u0026#34;æ¬è¿\u0026#34;è¿‡ \tb.tophash[i] = evacuatedEmpty // ç»§ç»­ä¸‹ä¸ª cell \tcontinue } // æ­£å¸¸ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µ \t// æœªè¢«æ¬è¿çš„ cell åªå¯èƒ½æ˜¯ empty æˆ–æ˜¯ \t// æ­£å¸¸çš„ top hashï¼ˆå¤§äº minTopHashï¼‰ \tif top \u0026lt; minTopHash { throw(\u0026#34;bad map state\u0026#34;) } k2 := k // å¦‚æœ key æ˜¯æŒ‡é’ˆï¼Œåˆ™è§£å¼•ç”¨ \tif t.indirectkey { k2 = *((*unsafe.Pointer)(k2)) } // é»˜è®¤ä½¿ç”¨ Xï¼Œç­‰é‡æ‰©å®¹ \tuseX := true // å¦‚æœä¸æ˜¯ç­‰é‡æ‰©å®¹ \tif !h.sameSizeGrow() { // è®¡ç®— hash å€¼ï¼Œå’Œ key ç¬¬ä¸€æ¬¡å†™å…¥æ—¶ä¸€æ · \thash := alg.hash(k2, uintptr(h.hash0)) // å¦‚æœæœ‰åç¨‹æ­£åœ¨éå† map \tif h.flags\u0026amp;iterator != 0 { // å¦‚æœå‡ºç° ç›¸åŒçš„ key å€¼ï¼Œç®—å‡ºæ¥çš„ hash å€¼ä¸åŒ \tif !t.reflexivekey \u0026amp;\u0026amp; !alg.equal(k2, k2) { // åªæœ‰åœ¨ float å˜é‡çš„ NaN() æƒ…å†µä¸‹ä¼šå‡ºç° \tif top\u0026amp;1 != 0 { // ç¬¬ B ä½ç½® 1 \thash |= newbit } else { // ç¬¬ B ä½ç½® 0 \thash \u0026amp;^= newbit } // å–é«˜ 8 ä½ä½œä¸º top hash å€¼ \ttop = uint8(hash \u0026gt;\u0026gt; (sys.PtrSize*8 - 8)) if top \u0026lt; minTopHash { top += minTopHash } } } // å–å†³äºæ–°å“ˆå¸Œå€¼çš„ oldB+1 ä½æ˜¯ 0 è¿˜æ˜¯ 1 \tuseX = hash\u0026amp;newbit == 0 } // å¦‚æœ key æ¬åˆ° X éƒ¨åˆ† \tif useX { // æ ‡å¿—è€çš„ cell çš„ top hash å€¼ï¼Œè¡¨ç¤ºæ¬ç§»åˆ° X éƒ¨åˆ† \tb.tophash[i] = evacuatedX // å¦‚æœ xi ç­‰äº 8ï¼Œè¯´æ˜è¦æº¢å‡ºäº† \tif xi == bucketCnt { // æ–°å»ºä¸€ä¸ª bucket \tnewx := h.newoverflow(t, x) x = newx // xi ä» 0 å¼€å§‹è®¡æ•° \txi = 0 // xk è¡¨ç¤º key è¦ç§»åŠ¨åˆ°çš„ä½ç½® \txk = add(unsafe.Pointer(x), dataOffset) // xv è¡¨ç¤º value è¦ç§»åŠ¨åˆ°çš„ä½ç½® \txv = add(xk, bucketCnt*uintptr(t.keysize)) } // è®¾ç½® top hash å€¼ \tx.tophash[xi] = top // key æ˜¯æŒ‡é’ˆ \tif t.indirectkey { // å°†åŸ keyï¼ˆæ˜¯æŒ‡é’ˆï¼‰å¤åˆ¶åˆ°æ–°ä½ç½® \t*(*unsafe.Pointer)(xk) = k2 // copy pointer \t} else { // å°†åŸ keyï¼ˆæ˜¯å€¼ï¼‰å¤åˆ¶åˆ°æ–°ä½ç½® \ttypedmemmove(t.key, xk, k) // copy value \t} // value æ˜¯æŒ‡é’ˆï¼Œæ“ä½œåŒ key \tif t.indirectvalue { *(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v) } else { typedmemmove(t.elem, xv, v) } // å®šä½åˆ°ä¸‹ä¸€ä¸ª cell \txi++ xk = add(xk, uintptr(t.keysize)) xv = add(xv, uintptr(t.valuesize)) } else { // key æ¬åˆ° Y éƒ¨åˆ†ï¼Œæ“ä½œåŒ X éƒ¨åˆ† \t// â€¦â€¦ \t// çœç•¥äº†è¿™éƒ¨åˆ†ï¼Œæ“ä½œå’Œ X éƒ¨åˆ†ç›¸åŒ \t} } } // å¦‚æœæ²¡æœ‰åç¨‹åœ¨ä½¿ç”¨è€çš„ bucketsï¼Œå°±æŠŠè€ buckets æ¸…é™¤æ‰ï¼Œå¸®åŠ©gc \tif h.flags\u0026amp;oldIterator == 0 { b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) // åªæ¸…é™¤bucket çš„ key,value éƒ¨åˆ†ï¼Œä¿ç•™ top hash éƒ¨åˆ†ï¼ŒæŒ‡ç¤ºæ¬è¿çŠ¶æ€ \tif t.bucket.kind\u0026amp;kindNoPointers == 0 { memclrHasPointers(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset) } else { memclrNoHeapPointers(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset) } } } // æ›´æ–°æ¬è¿è¿›åº¦ \t// å¦‚æœæ­¤æ¬¡æ¬è¿çš„ bucket ç­‰äºå½“å‰è¿›åº¦ \tif oldbucket == h.nevacuate { // è¿›åº¦åŠ  1 \th.nevacuate = oldbucket + 1 // Experiments suggest that 1024 is overkill by at least an order of magnitude. \t// Put it in there as a safeguard anyway, to ensure O(1) behavior. \t// å°è¯•å¾€åçœ‹ 1024 ä¸ª bucket \tstop := h.nevacuate + 1024 if stop \u0026gt; newbit { stop = newbit } // å¯»æ‰¾æ²¡æœ‰æ¬è¿çš„ bucket \tfor h.nevacuate != stop \u0026amp;\u0026amp; bucketEvacuated(t, h, h.nevacuate) { h.nevacuate++ } // ç°åœ¨ h.nevacuate ä¹‹å‰çš„ bucket éƒ½è¢«æ¬è¿å®Œæ¯• \t// æ‰€æœ‰çš„ buckets æ¬è¿å®Œæ¯• \tif h.nevacuate == newbit { // æ¸…é™¤è€çš„ buckets \th.oldbuckets = nil // æ¸…é™¤è€çš„ overflow bucket \t// å›å¿†ä¸€ä¸‹ï¼š[0] è¡¨ç¤ºå½“å‰ overflow bucket \t// [1] è¡¨ç¤º old overflow bucket \tif h.extra != nil { h.extra.overflow[1] = nil } // æ¸…é™¤æ­£åœ¨æ‰©å®¹çš„æ ‡å¿—ä½ \th.flags \u0026amp;^= sameSizeGrow } } }   æ¬è¿çš„ç›®çš„æ˜¯å°†è€æ¡¶å†…çš„æ•°æ®è¿ç§»åˆ°æ–°æ¡¶å†…ã€‚å¯¹äºæ¡ä»¶1ç¿»å€æ‰©å®¹ï¼Œæ–°æ¡¶çš„æ•°é‡æ˜¯è€æ¡¶çš„ä¸¤å€ï¼›å¯¹äºæ¡ä»¶2ç­‰é‡æ‰©å®¹ï¼Œæ–°æ¡¶çš„æ•°é‡ä¸ä¹‹å‰ç›¸ç­‰ã€‚\nå¯¹äºç­‰é‡æ‰©å®¹ï¼Œå› ä¸ºæ¡¶çš„æ•°é‡ä¸å˜ï¼Œæ‰€ä»¥å¯ä»¥æŒ‰åºå·è¿›è¡Œæ¬è¿ã€‚æ¯”å¦‚åŸæ¥æ˜¯0å·æ¡¶çš„ï¼Œåœ¨æ‰©å®¹è¿ç§»ä¹‹åï¼Œè¿˜æ˜¯å­˜æ”¾åœ¨0å·æ¡¶å†…ã€‚\nå¯¹äºç¿»å€æ‰©å®¹ï¼Œåˆ™éœ€è¦é‡å†™è®¡ç®—keyçš„å“ˆå¸Œå€¼ï¼Œæ¥å†³å®šå°†è¦è½å…¥å“ªä¸ªæ¡¶ä¸­ã€‚ä¾‹å¦‚ï¼ŒåŸæ¥ B = 5ï¼Œè®¡ç®—å‡º key çš„å“ˆå¸Œåï¼Œåªç”¨çœ‹å®ƒçš„ä½ 5 ä½ï¼Œå°±èƒ½å†³å®šå®ƒè½åœ¨å“ªä¸ª bucketã€‚æ‰©å®¹åï¼ŒB å˜æˆäº† 6ï¼Œå› æ­¤éœ€è¦å¤šçœ‹ä¸€ä½ï¼Œå®ƒçš„ä½ 6 ä½å†³å®š key è½åœ¨å“ªä¸ª bucketã€‚è¿™ç§°ä¸º rehashã€‚\nå› æ­¤ï¼Œkeyåœ¨æ¬è¿å‰åbucketåºå·å¯èƒ½ä¸åŸæ¥ä¸€è‡´ï¼Œä¹Ÿå¯èƒ½æ˜¯åŸæ¥çš„åºå·åŠ ä¸Š2^Bï¼ˆåŸæ¥çš„Bå€¼ï¼‰,å–å†³äº hash å€¼ ç¬¬ 6 bit ä½æ˜¯ 0 è¿˜æ˜¯ 1ã€‚\nå†æ˜ç¡®ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœæ‰©å®¹åï¼ŒB å¢åŠ äº† 1ï¼Œæ„å‘³ç€ buckets æ€»æ•°æ˜¯åŸæ¥çš„ 2 å€ï¼ŒåŸæ¥ 1 å·çš„æ¡¶â€œè£‚å˜â€åˆ°ä¸¤ä¸ªæ¡¶ã€‚\nä¾‹å¦‚ï¼ŒåŸå§‹ B = 2ï¼Œ1å· bucket ä¸­æœ‰ 2 ä¸ª key çš„å“ˆå¸Œå€¼ä½ 3 ä½åˆ†åˆ«ä¸ºï¼š010ï¼Œ110ã€‚ç”±äºåŸæ¥ B = 2ï¼Œæ‰€ä»¥ä½ 2 ä½ 10 å†³å®šå®ƒä»¬è½åœ¨ 2 å·æ¡¶ï¼Œç°åœ¨ B å˜æˆ 3ï¼Œæ‰€ä»¥ 010ã€110 åˆ†åˆ«è½å…¥ 2ã€6 å·æ¡¶ã€‚\nevacuate() å‡½æ•°æ¯æ¬¡åªå®Œæˆä¸€ä¸ª bucket çš„æ¬è¿å·¥ä½œï¼Œå› æ­¤è¦éå†å®Œæ­¤ bucket çš„æ‰€æœ‰çš„ cellï¼Œå°†æœ‰å€¼çš„ cell copy åˆ°æ–°çš„åœ°æ–¹ã€‚bucket è¿˜ä¼šé“¾æ¥ overflow bucketï¼Œå®ƒä»¬åŒæ ·éœ€è¦æ¬è¿ã€‚å› æ­¤ä¼šæœ‰ 2 å±‚å¾ªç¯ï¼Œå¤–å±‚éå† bucket å’Œ overflow bucketï¼Œå†…å±‚éå† bucket çš„æ‰€æœ‰ cellã€‚\næºç é‡Œæåˆ° X, Y partï¼Œå…¶å®å°±æ˜¯æˆ‘ä»¬è¯´çš„å¦‚æœæ˜¯æ‰©å®¹åˆ°åŸæ¥çš„ 2 å€ï¼Œæ¡¶çš„æ•°é‡æ˜¯åŸæ¥çš„ 2 å€ï¼Œå‰ä¸€åŠæ¡¶è¢«ç§°ä¸º X partï¼Œåä¸€åŠæ¡¶è¢«ç§°ä¸º Y partã€‚ä¸€ä¸ª bucket ä¸­çš„ key å¯èƒ½ä¼šåˆ†è£‚è½åˆ° 2 ä¸ªæ¡¶ï¼Œä¸€ä¸ªä½äº X partï¼Œä¸€ä¸ªä½äº Y partã€‚æ‰€ä»¥åœ¨æ¬è¿ä¸€ä¸ª cell ä¹‹å‰ï¼Œéœ€è¦çŸ¥é“è¿™ä¸ª cell ä¸­çš„ key æ˜¯è½åˆ°å“ªä¸ª Partã€‚å¾ˆç®€å•ï¼Œé‡æ–°è®¡ç®— cell ä¸­ key çš„ hashï¼Œå¹¶å‘å‰â€œå¤šçœ‹â€ä¸€ä½ï¼Œå†³å®šè½å…¥å“ªä¸ª Partï¼Œè¿™ä¸ªå‰é¢ä¹Ÿè¯´å¾—å¾ˆè¯¦ç»†äº†ã€‚\nç¡®å®šäº†è¦æ¬è¿åˆ°çš„ç›®æ ‡ bucket åï¼Œæ¬è¿æ“ä½œå°±æ¯”è¾ƒå¥½è¿›è¡Œäº†ã€‚å°†æº key/value å€¼ copy åˆ°ç›®çš„åœ°ç›¸åº”çš„ä½ç½®ã€‚\nè®¾ç½® key åœ¨åŸå§‹ buckets çš„ tophash ä¸º evacuatedX æˆ–æ˜¯ evacuatedYï¼Œè¡¨ç¤ºå·²ç»æ¬è¿åˆ°äº†æ–° map çš„ x part æˆ–æ˜¯ y partã€‚æ–° map çš„ tophash åˆ™æ­£å¸¸å– key å“ˆå¸Œå€¼çš„é«˜ 8 ä½ã€‚\nä¸‹é¢é€šè¿‡å›¾æ¥å®è§‚åœ°çœ‹ä¸€ä¸‹æ‰©å®¹å‰åçš„å˜åŒ–ã€‚\næ‰©å®¹å‰ï¼ŒB = 2ï¼Œå…±æœ‰ 4 ä¸ª bucketsï¼Œlowbits è¡¨ç¤º hash å€¼çš„ä½ä½ã€‚å‡è®¾æˆ‘ä»¬ä¸å…³æ³¨å…¶ä»– buckets æƒ…å†µï¼Œä¸“æ³¨åœ¨ 2 å· bucketã€‚å¹¶ä¸”å‡è®¾ overflow å¤ªå¤šï¼Œè§¦å‘äº†ç­‰é‡æ‰©å®¹ï¼ˆå¯¹åº”äºå‰é¢çš„æ¡ä»¶ 2ï¼‰ã€‚\næ‰©å®¹å®Œæˆåï¼Œoverflow bucket æ¶ˆå¤±äº†ï¼Œkey éƒ½é›†ä¸­åˆ°äº†ä¸€ä¸ª bucketï¼Œæ›´ä¸ºç´§å‡‘äº†ï¼Œæé«˜äº†æŸ¥æ‰¾çš„æ•ˆç‡ã€‚\nå‡è®¾è§¦å‘äº† 2 å€çš„æ‰©å®¹ï¼Œé‚£ä¹ˆæ‰©å®¹å®Œæˆåï¼Œè€ buckets ä¸­çš„ key åˆ†è£‚åˆ°äº† 2 ä¸ª æ–°çš„ bucketã€‚ä¸€ä¸ªåœ¨ x partï¼Œä¸€ä¸ªåœ¨ y çš„ partã€‚ä¾æ®æ˜¯ hash çš„ lowbitsã€‚æ–° map ä¸­ 0-3 ç§°ä¸º x partï¼Œ4-7 ç§°ä¸º y partã€‚\næ— è®ºå“ªç§æ‰©å®¹ï¼Œæ‰©å®¹æ“ä½œéƒ½ä¸æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œè€Œæ˜¯æ¸è¿›å¼çš„æ‰©å®¹ï¼Œä¼šåœ¨mapçš„æ’å…¥ã€ä¿®æ”¹ã€åˆ é™¤æ“ä½œæ˜¯å°è¯•æ¬è¿æ¡¶çš„å·¥ä½œï¼Œä¹Ÿå°±æ˜¯æ‰§è¡Œ growWork()å‡½æ•°ã€‚\nåˆ é™¤ æƒ³è¦åˆ é™¤mapä¸­çš„å…ƒç´ ï¼Œéœ€è¦ä½¿ç”¨å…³é”®å­— deleteã€‚è¿™ä¸ªå…³é”®å­—çš„å”¯ä¸€ä½œç”¨å°±æ˜¯å°†æŸä¸€ä¸ªé”®å¯¹åº”çš„å…ƒç´ ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œæ— è®ºæ˜¯è¯¥é”®å¯¹åº”çš„å€¼æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¸ªå†…å»ºçš„å‡½æ•°éƒ½ä¸ä¼šè¿”å›ä»»ä½•çš„ç»“æœã€‚\nåˆ é™¤æ“ä½œé¦–å…ˆä¼šæ£€æŸ¥ h.flag æ ‡å¿—ï¼Œå¦‚æœå‘ç°å†™æ ‡ä½æ˜¯ 1ï¼Œç›´æ¥ panicï¼Œå› ä¸ºè¿™è¡¨æ˜æœ‰å…¶ä»–åç¨‹åŒæ—¶åœ¨è¿›è¡Œå†™æ“ä½œã€‚ç„¶åè®¡ç®— key çš„å“ˆå¸Œï¼Œæ‰¾åˆ°è½å…¥çš„ bucketã€‚æ£€æŸ¥æ­¤ map å¦‚æœæ­£åœ¨æ‰©å®¹çš„è¿‡ç¨‹ä¸­ï¼Œç›´æ¥è§¦å‘ä¸€æ¬¡æ¬è¿æ“ä½œã€‚\n","date":"2023-12-20T16:43:23+08:00","permalink":"https://example.com/p/golang-notes%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Golang Notesï¼šæ•°æ®ç±»å‹"}]